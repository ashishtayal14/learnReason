/* --Just dumping JavaScript in the middle of your Reason code-- */

/* If you're just hacking things together, this can be very nice, but you also have all of the unsafety of JavaScript code ðŸ˜„. */

Js.log("this is reason");

[%bs.raw {| console.log('here is some javascript for you') |}];
/* {| and |} are the delimiters of a multi-line string in OCaml. You can also put a tag in there e.g. {something| and then it will look for a matching |something} to close. */

/* And here's the resulting javascript:

// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';
console.log("this is reason");
console.log('here is some javascript for you');
Dumping in some JavaScript, and making it accessible from Reason
What if you want a value that can be used from your Reason code? */

Js.log("this is reason");
let x = [%bs.raw {| 'here is a string from javascript' |}];
Js.log(x ++ " back in reason land"); /* ++ is the operator for string concat */
/* Now you might be wondering "what magic is this?? How did ocaml know that x was a string?" It doesn't. The type of x in this code is a magic type that will unify with anything! This is quite dangerous and can have cascading effects in OCaml's type inference algorithm. */

let y = [%bs.raw {| 'something' |}];
Js.log(("a string" ++ y, 10 + y));
/* danger!! ocaml won't stop you from using y as 2 totally different types */
/* To fix this, you should always provide a concrete type for the result of bs.raw. */

let x: string = [%bs.raw {| 'well-typed' |}];
Js.log(x ++ " back in reason land");
/* ocaml will error out if you try to use x as anything other than a string */


/* --Dumping in a function & passing values-- */

/* We'll need a little knowledge about Bucklescript's runtime representation of various values for this to work.

strings are strings, ints and floats are just numbers
an Array is a mutable fixed-length list in OCaml, and is represented as a plain javascript array.
a List is an immutable functional-style linked list, and is definitely the more idiomatic one to use in most cases. However, its representation is more complicated (try Js.log([1,2,3,4]) to check it out). Because of this, I generally convert to & from Arrays when I'm talking to javascript, via Array.of_list and Array.to_list.
If you want to go deeper, there's a list in the BuckleScript documentation
Knowing that, we can write a function in JavaScript that just accepts an array and returns a number, without much trouble at all. */

let jsCalculate: (array(int), int) => int = [%bs.raw
  {|
 function (numbers, scaleFactor) {
   var result = 0;
   numbers.forEach(number => {
     result += number;
   });
   return result * scaleFactor;
 }
|}
];

let calculate = (numbers, scaleFactor) => jsCalculate(Array.of_list(numbers), scaleFactor);

Js.log(calculate([1, 2, 3], 10)); /* -> 60 */

/* --Settling down and getting disciplined about things-- */

/* So far we've been using bs.raw, which is a very fast and loose way to do it, and not suitable for production. */

/* But what if we actually need to call a function that's in JavaScript? It's needed for interacting with the DOM, or using node modules. In BuckleScript, you use an external declaration (docs). */

/* Getting a value and getting a function are both pretty easy: */

[@bs.val] external pi : float = "Math.PI";
let tau = pi *. 2.0;
[@bs.val] external alert : string => unit = "alert";
alert("hello");